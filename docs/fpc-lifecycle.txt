@startuml
actor	Client1
entity	Peer1
entity	Peer2
database Ledger

group System setup

   Client1 -> Peer1 : start
   Client1 -> Peer2 : start

   Client1 -> Peer1 : channel create

   Client1 -> Peer1 : channel join
   note right
   	ercc et al. installed and instantiated (as channel creator),
	llcc channel join
   	transparently to clients
   end note
   Client1 -> Peer2 : channel join
   note right
   	ercc et al. installed (but not instantiated)
	llcc channel join
   	transparently to clients

	Q: could we potentially embedd this in
	   channel (genneration) block? This
	   would simplify flow ..
   end note

end

group Per FPC chaincode FCC

   Client1 -> Peer1 : chaincode install FCC
   note right
   	create (override) run-container,
   	potentiall/eventually also build container
   	if artifact is source (as other Fabric CC)
   end note
   Client1 -> Peer2 : chaincode install FCC
   note left
	Only difference for client compared to other chaincode
	is that it has to be installed as language 'fpc-c'.
   end note

   Client1 -> Peer1 : chaincode instantiate FCC
   note right
      Instantiate should only be done by one client but other peers
      also should have enclaves. Can we do that transparently or do we
      need a different admin call?
   end note

   Client1 -> Peer1 : chaincode query FPC-GET-ECC-PK
   note left
	The client has to get the PKs of the enclave involved in FCC.
        Validation depends on the trust setup (but unchanged from what
        is also necessary in standard fabric):
        - if client is in same Org than peer1, "normal" peer channel 
          security is sufficient
        - if client does not share trust-domain with any peer, then
           Client has to contact multiple peers until sufficient confirmations 
           are found or might have to act as its own peer and participate 
           actively in the channel.
   end note

   loop
      Client1 -> Peer1 : chaincode [query | invoke ] FCC
      note left
	Client1 will encrypt private inputs with ECC encryption PK
        and authenticated response of queries using ECC's signature PK.
      end note
      note right
      	   Q: who handles gathering endorsements for invoke?
	   Q: query served from local ledger-state without transaction?
      end note
      Client1 <- Peer1 : result
   end
end

@enduml

