/'
    Copyright 2020 Intel Corporation
    Copyright IBM Corp. All Rights Reserved.

    SPDX-License-Identifier: Apache-2.0
'/

@startuml

title FPC Enclave Registration

actor "Admin Org1" as Admin order 10
participant "E_Manager" as E_Manager order 15
participant "ECC Peer1_Org1" as ECC1 order 20
participant "ERCC Peer1_Org1" as ERCC1 order 40
participant "ERCC Peer1_Org2" as ERCC2 order 50

entity IAS order 1

note over IAS, ERCC2
Types are shown in the fpc-components diagram.
end note

note over ERCC1, ERCC2 #FFaa00
  It is assumed that:
    -channel has already been created;
    -ERCC has been installed -- approved by the participating organizations, see lifecycle;
    -ERCC contains hard-coded the TLCC_MRenclave and the IAS Root Certificate;
    -ERCC has an Endorsement Policy that requires signatures from a majority of orgs,
     for security reasons -- namely to avoid unilateral modifications and preserve
     integrity. As a result, changes to chaincode enclave info stored in ERCC will
     be dependent on such policy.
end note

group enclave creation
  activate Admin

  note over Admin #FFaa00
    These operations are assumed to be performed only after the chaincode definition is
    committed on the channel for two reasons:
    1) chaincode invocation may not be available before the definition is committed,
    2) enclave registration should be feasible only for committed chaincodes

    PS: in a future tighter integration with fabric we could remove the first constraint
    and could potentially piggyback the steps before the ercc registration (enclave and
    evidence generation) in the `approveformyorg` and the registration as part of
    `commit` without having to change the protocol flows.
  end note

  note over Admin, E_Manager #FFaa00
    The E_Manager component hides some operations that do not necessarily need to be
    performed by the Admin -- they could be scripted or embedded in the peer process;
    depending on the actual implementation it may require admin credential on the peer.
  end note

  Admin -> E_Manager ++: create

  E_Manager -> ECC1 ++: create

  create Enclave1 order 30 #99FF99
  ECC1 -> Enclave1 ++: create

  note over Enclave1 #FFaa00
    The CC_Parameters help binding the enclave to a specific chaincode,
    as it is registered in Fabric.
    The requirement of CC_Paramenters can be met in practice as follows:
    cc id, version, MSPID and channel id can be retrieved through Fabric shim functions;
    tlcc mrenclave can be retrieved through ercc;
    the validation of these parameters occurs when the registration tx is processed by ercc;
    if necessary, a pre-validation can be performed through tlcc.
    Another alternative could be to pass these parameters as part of the create call.
  end note
  Enclave1 -> Enclave1: fetch CC_Parameters

  note over Enclave1 #FFaa00
    This step generates the enclave's private keys used by the FPC chaincode
    to sign statements and set up secure channels.
    Check out the Components diagram to visualize Public_Keys/Private_Keys data structures.
  end note
  Enclave1 -> Enclave1 : Private_Keys <- generate_keys()
  Enclave1 -> Enclave1 : Public_Keys <- Public(Private_Keys)

  Enclave1 -> Enclave1 : Attested_Data <- <CC_Parameters, Public_Keys>

group "enclave attestation: Evidence <- GetEvidence(Attested_Data)"
  note over E_Manager #FFaa00
    As the EPID attestation requires the SPID, we let the E_Manager provide it.
    In a concrete implementation, the E_Manager could explicitly send the SPID to ECC_Enclave.
    Also, the SPID could be made an optional argument within an Aux_Data field.
    This would allow for the generalization of the attestation, to enable DCAP.
  end note
  Enclave1-> E_Manager ++: getSPID
  return SPID

  Enclave1 -> Enclave1 : Attestation <- attest(SPID, Attested_Data)
  note left #FFaa00
    quote is defined with reportbody = Hash(<Attested_Data>)
  end note

  note over Enclave1 #FFaa00
    Ideally the enclave itself is able to retrieve the verifiable evidence
    (i.e., the verification report, using EPID) and return it.
    This additionally requires some ocalls and helper code in untrusted environment.
    For convenience, the enclave now returns the attestation, and the evidence
    (i.e., the verification report) is retrieved from untrusted environment.
  end note
  Enclave1 -> IAS ++: Attestation
  return Evidence <- Verification_Report
end group

  Enclave1 -> Enclave1 : Sealed_Credentials <- seal(CC_Parameters, Private_Keys)

  note over Enclave1
    The constant string "CREATE" in the Verb field is meant to be used only here
    (in the create call). A different constant string is expected to be used whenever
    the Credentials prototobuf is reused (e.g., to re-attest the chaincode). This
    allows to distinguish different calls. 
  end note
  Enclave1 -> Enclave1 : Credentials <- <Verb="CREATE", Attested_Data, Evidence>
  return Credentials, Sealed_Credentials

  return Credentials, Sealed_Credentials

  E_Manager -> E_Manager : store Sealed_Credentials

  return result /' Admin -> E_Manager '/

  deactivate Admin

end

group Org-Enclave binding/certification (to be implemented)
  Admin -> E_Manager ++: certify
  E_Manager -> ECC1 ++: getCSR
  ECC1 -> Enclave1 ++: getCSR
  Enclave1 -> Enclave1 : csr <- generate_csr(Private_Keys.Enclave_SK)
  return csr /' ECC1 -> Enclave1 '/
  return csr /' E_Manager -> ECC1 '/
  E_Manager -> E_Manager : generate peer certificate for enclave (certified by Org_1)
  E_Manager -> E_Manager : store Certificate
  return
  note over Admin, E_Manager #FFaa00
    -Org_1 takes "ownership" of this enclave,
    -the certificate should be made available to the chaincode endorsement plugin,
     so to include it in the responses (for eventual validation) 
  end note
end group

group enclave registration
  activate Admin
  Admin -> E_Manager ++: register
  
  group invoke ERCC register
  E_Manager -> ERCC1 ++: register Credentials, Certificate

  note over ERCC1 #FFaa00
    The evidence check ensures that the evidence is signed by IAS
    and covers the attested data.
  end note
  ERCC1 -> ERCC1 : check Credentials.Evidence
  ERCC1 -> ERCC1 : check Credentials.Attested_Data.CC_Parameters (Channel_Id, MSPID of sender, TLCC_MREnclave)
  ERCC1 -> ERCC1 : check Certificate

  group check consistency of Credentials (TBD)
    note over ERCC1 #FFaa00
        It is crucial for ERCC to perform queries over (or have access to) the chaincode
        definition. Querying (or retrieving) the chaincode definition through TLCC is the
        most convenient way to implement this with least impact on core Fabric code.
        Future tighter integration in Fabric could also change that to more direct ways
        to feed it to ERCC.
    end note

    create "TLCC Peer1_Org1" as TLCC1 order 45
    create "TLCC_Enclave1" as TLCC_Enclave1 order 46
    TLCC1 -[hidden]> TLCC_Enclave1: hidden
    note over TLCC1, TLCC_Enclave1 #FFaa00
        The presence of TLCC_Enclave1, and the absence of messages to it, is to further
        emphasize that here it is only required a (possibly untrusted) system chaincode
        in Fabric to look up the chaincode definition. Again, using TLCC is convenient,
        but an enclave is not necessary.
    end note

    ERCC1 -> TLCC1  ++: approve consistency of Credentials


    TLCC1 -> TLCC1    : check Credentials against chaincode definition
    note over TLCC1 #FFaa00
        This check ensures that:
        1) the chaincode version (i.e., the MREnclave) matches the version of the
            approved chaincode.
        2) the chaincode is registered
        Note that (1) is security-critical and saves the client from verifying the
        chaincode version/MREnclave.
        Note that (2) merely prevents spurious chaincode enclaves from being registered.
    end note
    return result
  end group

  group deployment validation (unclear, TBD)
    ERCC1 -> ERCC1 : validate FPC deployment (restriction) policy
    note left #FFaa00
      related risk management (v2.0 feature TBD)
    end note
  end group

  ERCC1 -> ERCC1 : store Credentials on the ledger
  note over ERCC1 #FFaa00
  E.g., putState(key=Credentials.CC_Id, value=Credentials)
  end note

  return register endorsement /' E_Manager -> ERCC1 '/
  end group

  ref over ERCC2
    invoke ERCC register
  endref

  ref over E_Manager
    submit transaction
  end ref

  return result

  deactivate Admin

end

@enduml
