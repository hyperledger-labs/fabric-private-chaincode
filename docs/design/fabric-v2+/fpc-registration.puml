/'
    Copyright 2020 Intel Corporation
    Copyright IBM Corp. All Rights Reserved.

    SPDX-License-Identifier: Apache-2.0
'/

@startuml

!pragma teoz true

title FPC Enclave Registration

actor "Admin" as Admin order 10
participant "Peer_CLI" as Peer_CLI order 15
participant "FPC_stub" as ECC1 order 20
participant "Ledger Enclave" as TLCC1 order 36 #99FF99
participant "ERCC" as ERCC1 order 40

entity IAS order 100
participant Orderer as Orderer order 100

note right Admin
Types are shown in the fpc-components diagram.
end note

note right Admin
  It is assumed that:
    -Channel has already been created;
    -ERCC has been installed -- approved by the participating organizations, see lifecycle;
    -ERCC contains hard-coded the TLCC_MRenclave and the IAS Root Certificate;
    -ERCC has an Endorsement Policy that requires signatures from a majority of orgs,
     for security reasons -- namely to avoid unilateral modifications and preserve
     integrity. As a result, changes to chaincode enclave info stored in ERCC will
     be dependent on such policy.
end note

Admin -> Peer_CLI ++: lifecycle chaincode\n createenclave (CC_Id)

group enclave creation
  note right Peer_CLI
    This operation can only be performed after the chaincode definition --- 
    which defines the root of trust (MRENCLAVE) for the FPC Chaincode --- 
    is committed on the channel. More specifically, this commitment must have 
    completed before below 'registerEnclave' starts  in order to complete the
    enclave registration step.
  end note

  Peer_CLI -> ECC1 ++: createEnclave (CC_Id)

  create "FPC_stub_enclave" as Enclave1 order 30 #99FF99
  ECC1 -> Enclave1 ++: createEnclave (CC_Id)

  Enclave1 -> Enclave1: fetch CC_Parameters
  note right Enclave1
    The CC_Parameters help binding the enclave to a specific FPC chaincode,
    as it is registered in Fabric.

    The requirement of CC_Paramenters can be met in practice as follows:
    CC_Id, version, MSPID, and channel id can be retrieved through Fabric
    shim functions; TLCC_mrenclave can be retrieved through ERCC;

    Note that the validation of these parameters is performed by ERCC.
    If necessary, a pre-validation can be performed through the Ledger Enclave.
    Another alternative could be to pass these parameters as argument in
    the createEnclave call.
  end note

  Enclave1 -> Enclave1 : <Public_Keys, Private_Keys>  <- generate keys
  note right Enclave1
    This step generates the enclave's public and private keys used by
    the FPC chaincode to sign transactions and decrypt transaction arguments.
    See fpc-components.uml diagram for more details
  end note

  Enclave1 -> Enclave1 : Attested_Data <- <CC_Parameters, Public_Keys>

  Enclave1 -> Enclave1 +: GetEvidence(Attested_Data)
  group enclave attestation - evidence creation
  note right Enclave1
    The GetEvidence method abstracts/generalizes the attestation protocol used here.
    Currently, Intel SGX supports two different attestation schemes, namely,
    EPID-based attestation and DCAP. For more details see Intel SGX docu.

    In this diagram we illustrate the flow of the EPID-based attestation, which
    involves Intel Attestation Service (IAS). As the EPID attestation requires
    the SPID to generate a quote, the peer provides it through FPC_stub.
  end note
  Enclave1-> Enclave1 ++: getSPID
  return SPID

  Enclave1 -> Enclave1 : quote <- create quote using SPID over Hash(Attested_Data)
  note right Enclave1
      There are differnt options to implmement getSPID:
      - FPC_stub could explicitly send the SPID to FPC_stub_enclave
      - SPID could be an optional argument within an Aux_Data field.
      - FPC_stub_enclave performs a ocall to fetch the SPID from FPC_stub
  end note

  Enclave1 -> IAS ++: send quote for verification
  note right Enclave1
    Ideally the enclave itself is able to retrieve the verifiable evidence
    (i.e., the verification report, using EPID) and return it.
    This additionally requires some ocalls and helper code in FPC_stub.
    For convenience, the enclave now returns the attestation, and the evidence
    (i.e., the verification report) is retrieved from untrusted environment.
  end note
  note left IAS
    IAS verifies the quote produced by the enclave and returns
    a signed verification report that is used as evidence that
    the enclave runs a certain FPC enclave in certain security context.
  end note
  return Evidence <- Verification_Report
  end group

   return Evidence

  Enclave1 -> Enclave1 : Sealed_Credentials <- seal <CC_Parameters, Private_Keys, Public_Keys>
  note right Enclave1
      The enclave keeps CC_Paramenters, Public_Keys, and Private_Keys as local state
      in memory during it's lifetime.  Once an enclave restarts, this state is
      deleted and must be restored. For this reason, the enclave state is sealed
      so it can be stored outside the enclave for recovery.
  end note

  Enclave1 -> Enclave1 : Credentials <- <Verb="CREATE", Attested_Data, Evidence>
  note right Enclave1
      The constant string "CREATE" in the Verb field is meant to be used only here
      (in the create call). A different constant string is expected to be used whenever
      the Credentials prototobuf is reused (e.g., to re-attest the chaincode). This
      allows to distinguish different calls.
  end note
  return Credentials, Sealed_Credentials

  ECC1 -> ECC1 : store Sealed_Credentials
  note right ECC1
    FPC_stub stores sealed chaincode credentials with the help of
    the external builder on the peer local storage.
  end note

group Org-Enclave binding/certification
  note right ECC1
    Here the Org takes "ownership" of this enclave by generating a certificate.
    In Post-MVP, this certificate is used by an FPC endorsement plugin,
    to replace the normal peer endorsement signature with the enclave signature.
  end note

  ECC1 -> Enclave1 ++: getCSR
  Enclave1 -> Enclave1 : csr <- generate_csr(Private_Keys.Enclave_SK)
  return csr /' ECC1 -> Enclave1 '/
  ECC1 -> ECC1 : generate peer certificate for enclave (certified by the Org)
  ECC1 -> ECC1 : store Certificate
    note right ECC1
      FPC_stub stores the binding certificate with the help of
      the external builder on the peer local storage but also
      returns it to the Peer_CLI.
    end note
end group
return Credentials, Certificate

end

  loop for all/"enough" endorsers
    Peer_CLI -> ERCC1 ++: registerEnclave (Credentials, Certificate)
    note right ERCC1
        Note that ERCC aborts if a single check failed.
    end note

    group enclave attestation - evidence validation
      ERCC1 -> ERCC1 : check Credentials.Evidence
      note right ERCC1
        The evidence check ensures that the evidence is correct (e.g. in
        case of EPID-based attestation the evidence must be signed by IAS)
        and covers the attested data.

        Note that the IAS verification key is hardcoded in ERCC. This
        verification key does not change frequently. In the case the verification
        key changes, the ERCC must be updated and upgraded through the normal
        chaincode lifecycle upgrade operation.
      end note
      ERCC1 -> ERCC1 : check Credentials.Attested_Data match CC_Parameters known to ERCC
      note right ERCC1
        In particular Channel_Id, MSPID of sender, TLCC_MRENCLAVE is verified
      end note
   end group

  ERCC1 -> ERCC1 : check Org-Enclave binding certificate

  group check consistency of Credentials (TBD)
    note right ERCC1
        It is crucial for ERCC to perform queries over (or have access to) the chaincode
        definition. Querying (or retrieving) the chaincode definition through TLCC is the
        most convenient way to implement this with least impact on core Fabric code.
        Future tighter integration in Fabric could also change that to more direct ways
        to feed it to ERCC.
    end note

    create Lifecycle order 55
    ERCC1 -> Lifecycle +: queryChaincodeDefinition
    return chaincode definition

    ERCC1 -> ERCC1    : check Credentials against chaincode definition
    note right ERCC1
        This check ensures that:
        1) the chaincode version (i.e., the MREnclave) matches the
            version of the approved chaincode.
        2) the chaincode is registered

        Note that (1) is security-critical and saves the client from
        verifying the chaincode version/MREnclave.

        Note that (2) merely prevents spurious chaincode enclaves from
        being registered.
    end note
  end group

  group Deployment validation
    ERCC1 -> ERCC1 : validate FPC deployment (restriction) policy
    note right ERCC1
      This is a POST-MVP feature related to risk management.
    end note
  end group

  ERCC1 -> ERCC1 : putState(CC_Id"."Credentials.Enclave_VK, Credentials)
  note over ERCC1
  end note

  return  proposal response
  end loop



  Peer_CLI -> Peer_CLI : form transaction
  Peer_CLI -> Orderer: submit registerEnclave transaction

  return

@enduml
